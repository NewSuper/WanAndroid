(self["webpackChunkant_design_pro"] =
  self["webpackChunkant_design_pro"] || []).push([
  [
    "mf-dep_vendors-node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js-node_modules_umij-b2093d"
  ],
  {
    /***/ "./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js":
      /*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js ***!
  \******************************************************************************/
      /***/ function(
        __unused_webpack___webpack_module__,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: function() {
            return /* binding */ _createForOfIteratorHelper;
          }
          /* harmony export */
        });
        /* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"
        );

        function _createForOfIteratorHelper(o, allowArrayLike) {
          var it =
            (typeof Symbol !== "undefined" && o[Symbol.iterator]) ||
            o["@@iterator"];

          if (!it) {
            if (
              Array.isArray(o) ||
              (it = (0,
              _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(
                o
              )) ||
              (allowArrayLike && o && typeof o.length === "number")
            ) {
              if (it) o = it;
              var i = 0;

              var F = function F() {};

              return {
                s: F,
                n: function n() {
                  if (i >= o.length)
                    return {
                      done: true
                    };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }

            throw new TypeError(
              "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          }

          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }

        /***/
      },

    /***/ "./node_modules/antd/es/avatar/style/index.less":
      /*!******************************************************!*\
  !*** ./node_modules/antd/es/avatar/style/index.less ***!
  \******************************************************/
      /***/ function() {
        // extracted by mini-css-extract-plugin
        if (false) {
          var cssReload;
        }

        /***/
      },

    /***/ "./node_modules/antd/es/button/style/index.less":
      /*!******************************************************!*\
  !*** ./node_modules/antd/es/button/style/index.less ***!
  \******************************************************/
      /***/ function() {
        // extracted by mini-css-extract-plugin
        if (false) {
          var cssReload;
        }

        /***/
      },

    /***/ "./node_modules/antd/es/config-provider/style/index.less":
      /*!***************************************************************!*\
  !*** ./node_modules/antd/es/config-provider/style/index.less ***!
  \***************************************************************/
      /***/ function() {
        // extracted by mini-css-extract-plugin
        if (false) {
          var cssReload;
        }

        /***/
      },

    /***/ "./node_modules/antd/es/divider/style/index.less":
      /*!*******************************************************!*\
  !*** ./node_modules/antd/es/divider/style/index.less ***!
  \*******************************************************/
      /***/ function() {
        // extracted by mini-css-extract-plugin
        if (false) {
          var cssReload;
        }

        /***/
      },

    /***/ "./node_modules/antd/es/drawer/style/index.less":
      /*!******************************************************!*\
  !*** ./node_modules/antd/es/drawer/style/index.less ***!
  \******************************************************/
      /***/ function() {
        // extracted by mini-css-extract-plugin
        if (false) {
          var cssReload;
        }

        /***/
      },

    /***/ "./node_modules/antd/es/dropdown/style/index.less":
      /*!********************************************************!*\
  !*** ./node_modules/antd/es/dropdown/style/index.less ***!
  \********************************************************/
      /***/ function() {
        // extracted by mini-css-extract-plugin
        if (false) {
          var cssReload;
        }

        /***/
      },

    /***/ "./node_modules/antd/es/empty/style/index.less":
      /*!*****************************************************!*\
  !*** ./node_modules/antd/es/empty/style/index.less ***!
  \*****************************************************/
      /***/ function() {
        // extracted by mini-css-extract-plugin
        if (false) {
          var cssReload;
        }

        /***/
      },

    /***/ "./node_modules/antd/es/grid/style/index.less":
      /*!****************************************************!*\
  !*** ./node_modules/antd/es/grid/style/index.less ***!
  \****************************************************/
      /***/ function() {
        // extracted by mini-css-extract-plugin
        if (false) {
          var cssReload;
        }

        /***/
      },

    /***/ "./node_modules/antd/es/popover/style/index.less":
      /*!*******************************************************!*\
  !*** ./node_modules/antd/es/popover/style/index.less ***!
  \*******************************************************/
      /***/ function() {
        // extracted by mini-css-extract-plugin
        if (false) {
          var cssReload;
        }

        /***/
      },

    /***/ "./node_modules/antd/es/select/style/index.less":
      /*!******************************************************!*\
  !*** ./node_modules/antd/es/select/style/index.less ***!
  \******************************************************/
      /***/ function() {
        // extracted by mini-css-extract-plugin
        if (false) {
          var cssReload;
        }

        /***/
      },

    /***/ "./node_modules/antd/es/spin/style/index.less":
      /*!****************************************************!*\
  !*** ./node_modules/antd/es/spin/style/index.less ***!
  \****************************************************/
      /***/ function() {
        // extracted by mini-css-extract-plugin
        if (false) {
          var cssReload;
        }

        /***/
      },

    /***/ "./node_modules/antd/es/style/index.less":
      /*!***********************************************!*\
  !*** ./node_modules/antd/es/style/index.less ***!
  \***********************************************/
      /***/ function() {
        // extracted by mini-css-extract-plugin
        if (false) {
          var cssReload;
        }

        /***/
      },

    /***/ "./node_modules/antd/es/switch/style/index.less":
      /*!******************************************************!*\
  !*** ./node_modules/antd/es/switch/style/index.less ***!
  \******************************************************/
      /***/ function() {
        // extracted by mini-css-extract-plugin
        if (false) {
          var cssReload;
        }

        /***/
      },

    /***/ "./node_modules/antd/es/tooltip/style/index.less":
      /*!*******************************************************!*\
  !*** ./node_modules/antd/es/tooltip/style/index.less ***!
  \*******************************************************/
      /***/ function() {
        // extracted by mini-css-extract-plugin
        if (false) {
          var cssReload;
        }

        /***/
      },

    /***/ "./node_modules/@umijs/use-params/es/index.js":
      /*!****************************************************!*\
  !*** ./node_modules/@umijs/use-params/es/index.js ***!
  \****************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ useUrlSearchParams: function() {
            return /* binding */ useUrlSearchParams;
          }
          /* harmony export */
        });
        /* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! react */ "./node_modules/react/index.js"
        );
        var __assign =
          (undefined && undefined.__assign) ||
          function() {
            __assign =
              Object.assign ||
              function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];
                  for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
              };
            return __assign.apply(this, arguments);
          };
        /* eslint-disable no-restricted-syntax */

        /**
         *
         * @param {object} params
         * @returns {URL}
         */
        function setQueryToCurrentUrl(params) {
          var _a;
          var URL = (typeof window !== "undefined" ? window : {}).URL;
          var url = new URL(
            (_a =
              window === null || window === void 0
                ? void 0
                : window.location) === null || _a === void 0
              ? void 0
              : _a.href
          );
          Object.keys(params).forEach(function(key) {
            var value = params[key];
            if (value !== null && value !== undefined) {
              if (Array.isArray(value)) {
                url.searchParams.delete(key);
                value.forEach(function(valueItem) {
                  url.searchParams.append(key, valueItem);
                });
              } else if (value instanceof Date) {
                if (!Number.isNaN(value.getTime())) {
                  url.searchParams.set(key, value.toISOString());
                }
              } else if (typeof value === "object") {
                url.searchParams.set(key, JSON.stringify(value));
              } else {
                url.searchParams.set(key, value);
              }
            } else {
              url.searchParams.delete(key);
            }
          });
          return url;
        }
        function useUrlSearchParams(initial, config) {
          var _a;
          if (initial === void 0) {
            initial = {};
          }
          if (config === void 0) {
            config = { disabled: false };
          }
          /**
           * The main idea of this hook is to make things response to change of `window.location.search`,
           * so no need for introducing new state (in the mean time).
           * Whenever `window.location.search` is changed but  not cause re-render, call `forceUpdate()`.
           * Whenever the component - user of this hook - re-render, this hook should return
           * the query object that corresponse to the current `window.location.search`
           */
          var _b = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(),
            forceUpdate = _b[1];
          var locationSearch =
            typeof window !== "undefined" &&
            ((_a =
              window === null || window === void 0
                ? void 0
                : window.location) === null || _a === void 0
              ? void 0
              : _a.search);
          /**
           * @type {URLSearchParams}
           */
          var urlSearchParams = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(
            function() {
              if (config.disabled) return {};
              return new URLSearchParams(locationSearch || {});
            },
            [config.disabled, locationSearch]
          );
          var params = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(
            function() {
              if (config.disabled) return {};
              if (typeof window === "undefined" || !window.URL) return {};
              var result = [];
              // @ts-ignore
              urlSearchParams.forEach(function(value, key) {
                result.push({
                  key: key,
                  value: value
                });
              });
              // group by key
              result = result.reduce(function(acc, val) {
                (acc[val.key] = acc[val.key] || []).push(val);
                return acc;
              }, {});
              result = Object.keys(result).map(function(key) {
                var valueGroup = result[key];
                if (valueGroup.length === 1) {
                  return [key, valueGroup[0].value];
                }
                return [
                  key,
                  valueGroup.map(function(_a) {
                    var value = _a.value;
                    return value;
                  })
                ];
              });
              var newParams = __assign({}, initial);
              result.forEach(function(_a) {
                var key = _a[0],
                  value = _a[1];
                newParams[key] = parseValue(key, value, {}, initial);
              });
              return newParams;
            },
            [config.disabled, initial, urlSearchParams]
          );
          function redirectToNewSearchParams(newParams) {
            if (typeof window === "undefined" || !window.URL) return;
            var url = setQueryToCurrentUrl(newParams);
            if (window.location.search !== url.search) {
              window.history.replaceState({}, "", url.toString());
            }
            if (urlSearchParams.toString() !== url.searchParams.toString()) {
              forceUpdate({});
            }
          }
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(
            function() {
              if (config.disabled) return;
              if (typeof window === "undefined" || !window.URL) return;
              redirectToNewSearchParams(
                __assign(__assign({}, initial), params)
              );
            },
            [config.disabled, params]
          );
          var setParams = function(newParams) {
            redirectToNewSearchParams(newParams);
          };
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(
            function() {
              if (config.disabled) return function() {};
              if (typeof window === "undefined" || !window.URL)
                return function() {};
              var onPopState = function() {
                forceUpdate({});
              };
              window.addEventListener("popstate", onPopState);
              return function() {
                window.removeEventListener("popstate", onPopState);
              };
            },
            [config.disabled]
          );
          return [params, setParams];
        }
        var booleanValues = {
          true: true,
          false: false
        };
        function parseValue(key, _value, types, defaultParams) {
          if (!types) return _value;
          var type = types[key];
          var value = _value === undefined ? defaultParams[key] : _value;
          if (type === Number) {
            return Number(value);
          }
          if (type === Boolean || _value === "true" || _value === "false") {
            return booleanValues[value];
          }
          if (Array.isArray(type)) {
            // eslint-disable-next-line eqeqeq
            return (
              type.find(function(item) {
                return item == value;
              }) || defaultParams[key]
            );
          }
          return value;
        }

        /***/
      },

    /***/ "./node_modules/antd/es/avatar/style/index.js":
      /*!****************************************************!*\
  !*** ./node_modules/antd/es/avatar/style/index.js ***!
  \****************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ../../style/index.less */ "./node_modules/antd/es/style/index.less"
        );
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
          _style_index_less__WEBPACK_IMPORTED_MODULE_0__
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! ./index.less */ "./node_modules/antd/es/avatar/style/index.less"
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
          _index_less__WEBPACK_IMPORTED_MODULE_1__
        );
        /* harmony import */ var _popover_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          /*! ../../popover/style */ "./node_modules/antd/es/popover/style/index.js"
        );

        // style dependencies
        // deps-lint-skip: grid

        /***/
      },

    /***/ "./node_modules/antd/es/button/style/index.js":
      /*!****************************************************!*\
  !*** ./node_modules/antd/es/button/style/index.js ***!
  \****************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ../../style/index.less */ "./node_modules/antd/es/style/index.less"
        );
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
          _style_index_less__WEBPACK_IMPORTED_MODULE_0__
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! ./index.less */ "./node_modules/antd/es/button/style/index.less"
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
          _index_less__WEBPACK_IMPORTED_MODULE_1__
        );

        /***/
      },

    /***/ "./node_modules/antd/es/calendar/locale/zh_CN.js":
      /*!*******************************************************!*\
  !*** ./node_modules/antd/es/calendar/locale/zh_CN.js ***!
  \*******************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _date_picker_locale_zh_CN__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ../../date-picker/locale/zh_CN */ "./node_modules/antd/es/date-picker/locale/zh_CN.js"
        );

        /* harmony default export */ __webpack_exports__["default"] =
          _date_picker_locale_zh_CN__WEBPACK_IMPORTED_MODULE_0__.default;

        /***/
      },

    /***/ "./node_modules/antd/es/config-provider/style/index.js":
      /*!*************************************************************!*\
  !*** ./node_modules/antd/es/config-provider/style/index.js ***!
  \*************************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ./index.less */ "./node_modules/antd/es/config-provider/style/index.less"
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
          _index_less__WEBPACK_IMPORTED_MODULE_0__
        );

        /***/
      },

    /***/ "./node_modules/antd/es/date-picker/locale/zh_CN.js":
      /*!**********************************************************!*\
  !*** ./node_modules/antd/es/date-picker/locale/zh_CN.js ***!
  \**********************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js"
        );
        /* harmony import */ var rc_picker_es_locale_zh_CN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! rc-picker/es/locale/zh_CN */ "./node_modules/rc-picker/es/locale/zh_CN.js"
        );
        /* harmony import */ var _time_picker_locale_zh_CN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          /*! ../../time-picker/locale/zh_CN */ "./node_modules/antd/es/time-picker/locale/zh_CN.js"
        );

        // 统一合并为完整的 Locale

        var locale = {
          lang: (0,
          _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)(
            {
              placeholder: "请选择日期",
              yearPlaceholder: "请选择年份",
              quarterPlaceholder: "请选择季度",
              monthPlaceholder: "请选择月份",
              weekPlaceholder: "请选择周",
              rangePlaceholder: ["开始日期", "结束日期"],
              rangeYearPlaceholder: ["开始年份", "结束年份"],
              rangeMonthPlaceholder: ["开始月份", "结束月份"],
              rangeWeekPlaceholder: ["开始周", "结束周"]
            },
            rc_picker_es_locale_zh_CN__WEBPACK_IMPORTED_MODULE_1__.default
          ),
          timePickerLocale: (0,
          _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__.default)(
            {},
            _time_picker_locale_zh_CN__WEBPACK_IMPORTED_MODULE_2__.default
          )
        }; // should add whitespace between char in Button

        locale.lang.ok = "确 定"; // All settings at:
        // https://github.com/ant-design/ant-design/blob/master/components/date-picker/locale/example.json

        /* harmony default export */ __webpack_exports__["default"] = locale;

        /***/
      },

    /***/ "./node_modules/antd/es/divider/style/index.js":
      /*!*****************************************************!*\
  !*** ./node_modules/antd/es/divider/style/index.js ***!
  \*****************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ../../style/index.less */ "./node_modules/antd/es/style/index.less"
        );
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
          _style_index_less__WEBPACK_IMPORTED_MODULE_0__
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! ./index.less */ "./node_modules/antd/es/divider/style/index.less"
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
          _index_less__WEBPACK_IMPORTED_MODULE_1__
        );

        /***/
      },

    /***/ "./node_modules/antd/es/drawer/style/index.js":
      /*!****************************************************!*\
  !*** ./node_modules/antd/es/drawer/style/index.js ***!
  \****************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ../../style/index.less */ "./node_modules/antd/es/style/index.less"
        );
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
          _style_index_less__WEBPACK_IMPORTED_MODULE_0__
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! ./index.less */ "./node_modules/antd/es/drawer/style/index.less"
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
          _index_less__WEBPACK_IMPORTED_MODULE_1__
        );
        // deps-lint-skip: empty

        /***/
      },

    /***/ "./node_modules/antd/es/dropdown/style/index.js":
      /*!******************************************************!*\
  !*** ./node_modules/antd/es/dropdown/style/index.js ***!
  \******************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ../../style/index.less */ "./node_modules/antd/es/style/index.less"
        );
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
          _style_index_less__WEBPACK_IMPORTED_MODULE_0__
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! ./index.less */ "./node_modules/antd/es/dropdown/style/index.less"
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
          _index_less__WEBPACK_IMPORTED_MODULE_1__
        );
        /* harmony import */ var _button_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          /*! ../../button/style */ "./node_modules/antd/es/button/style/index.js"
        );

        // style dependencies

        /***/
      },

    /***/ "./node_modules/antd/es/empty/style/index.js":
      /*!***************************************************!*\
  !*** ./node_modules/antd/es/empty/style/index.js ***!
  \***************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ../../style/index.less */ "./node_modules/antd/es/style/index.less"
        );
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
          _style_index_less__WEBPACK_IMPORTED_MODULE_0__
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! ./index.less */ "./node_modules/antd/es/empty/style/index.less"
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
          _index_less__WEBPACK_IMPORTED_MODULE_1__
        );

        /***/
      },

    /***/ "./node_modules/antd/es/grid/style/index.js":
      /*!**************************************************!*\
  !*** ./node_modules/antd/es/grid/style/index.js ***!
  \**************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ../../style/index.less */ "./node_modules/antd/es/style/index.less"
        );
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
          _style_index_less__WEBPACK_IMPORTED_MODULE_0__
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! ./index.less */ "./node_modules/antd/es/grid/style/index.less"
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
          _index_less__WEBPACK_IMPORTED_MODULE_1__
        );

        /***/
      },

    /***/ "./node_modules/antd/es/locale/zh_CN.js":
      /*!**********************************************!*\
  !*** ./node_modules/antd/es/locale/zh_CN.js ***!
  \**********************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var rc_pagination_es_locale_zh_CN__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! rc-pagination/es/locale/zh_CN */ "./node_modules/rc-pagination/es/locale/zh_CN.js"
        );
        /* harmony import */ var _date_picker_locale_zh_CN__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! ../date-picker/locale/zh_CN */ "./node_modules/antd/es/date-picker/locale/zh_CN.js"
        );
        /* harmony import */ var _time_picker_locale_zh_CN__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          /*! ../time-picker/locale/zh_CN */ "./node_modules/antd/es/time-picker/locale/zh_CN.js"
        );
        /* harmony import */ var _calendar_locale_zh_CN__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          /*! ../calendar/locale/zh_CN */ "./node_modules/antd/es/calendar/locale/zh_CN.js"
        );
        /* eslint-disable no-template-curly-in-string */

        var typeTemplate = "${label}不是一个有效的${type}";
        var localeValues = {
          locale: "zh-cn",
          Pagination:
            rc_pagination_es_locale_zh_CN__WEBPACK_IMPORTED_MODULE_0__.default,
          DatePicker:
            _date_picker_locale_zh_CN__WEBPACK_IMPORTED_MODULE_1__.default,
          TimePicker:
            _time_picker_locale_zh_CN__WEBPACK_IMPORTED_MODULE_2__.default,
          Calendar: _calendar_locale_zh_CN__WEBPACK_IMPORTED_MODULE_3__.default,
          // locales for all components
          global: {
            placeholder: "请选择"
          },
          Table: {
            filterTitle: "筛选",
            filterConfirm: "确定",
            filterReset: "重置",
            filterEmptyText: "无筛选项",
            selectAll: "全选当页",
            selectInvert: "反选当页",
            selectNone: "清空所有",
            selectionAll: "全选所有",
            sortTitle: "排序",
            expand: "展开行",
            collapse: "关闭行",
            triggerDesc: "点击降序",
            triggerAsc: "点击升序",
            cancelSort: "取消排序"
          },
          Modal: {
            okText: "确定",
            cancelText: "取消",
            justOkText: "知道了"
          },
          Popconfirm: {
            cancelText: "取消",
            okText: "确定"
          },
          Transfer: {
            searchPlaceholder: "请输入搜索内容",
            itemUnit: "项",
            itemsUnit: "项",
            remove: "删除",
            selectCurrent: "全选当页",
            removeCurrent: "删除当页",
            selectAll: "全选所有",
            removeAll: "删除全部",
            selectInvert: "反选当页"
          },
          Upload: {
            uploading: "文件上传中",
            removeFile: "删除文件",
            uploadError: "上传错误",
            previewFile: "预览文件",
            downloadFile: "下载文件"
          },
          Empty: {
            description: "暂无数据"
          },
          Icon: {
            icon: "图标"
          },
          Text: {
            edit: "编辑",
            copy: "复制",
            copied: "复制成功",
            expand: "展开"
          },
          PageHeader: {
            back: "返回"
          },
          Form: {
            optional: "（可选）",
            defaultValidateMessages: {
              default: "字段验证错误${label}",
              required: "请输入${label}",
              enum: "${label}必须是其中一个[${enum}]",
              whitespace: "${label}不能为空字符",
              date: {
                format: "${label}日期格式无效",
                parse: "${label}不能转换为日期",
                invalid: "${label}是一个无效日期"
              },
              types: {
                string: typeTemplate,
                method: typeTemplate,
                array: typeTemplate,
                object: typeTemplate,
                number: typeTemplate,
                date: typeTemplate,
                boolean: typeTemplate,
                integer: typeTemplate,
                float: typeTemplate,
                regexp: typeTemplate,
                email: typeTemplate,
                url: typeTemplate,
                hex: typeTemplate
              },
              string: {
                len: "${label}须为${len}个字符",
                min: "${label}最少${min}个字符",
                max: "${label}最多${max}个字符",
                range: "${label}须在${min}-${max}字符之间"
              },
              number: {
                len: "${label}必须等于${len}",
                min: "${label}最小值为${min}",
                max: "${label}最大值为${max}",
                range: "${label}须在${min}-${max}之间"
              },
              array: {
                len: "须为${len}个${label}",
                min: "最少${min}个${label}",
                max: "最多${max}个${label}",
                range: "${label}数量须在${min}-${max}之间"
              },
              pattern: {
                mismatch: "${label}与模式不匹配${pattern}"
              }
            }
          },
          Image: {
            preview: "预览"
          }
        };
        /* harmony default export */ __webpack_exports__[
          "default"
        ] = localeValues;

        /***/
      },

    /***/ "./node_modules/antd/es/popover/style/index.js":
      /*!*****************************************************!*\
  !*** ./node_modules/antd/es/popover/style/index.js ***!
  \*****************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ../../style/index.less */ "./node_modules/antd/es/style/index.less"
        );
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
          _style_index_less__WEBPACK_IMPORTED_MODULE_0__
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! ./index.less */ "./node_modules/antd/es/popover/style/index.less"
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
          _index_less__WEBPACK_IMPORTED_MODULE_1__
        );

        // style dependencies
        // deps-lint-skip: tooltip

        /***/
      },

    /***/ "./node_modules/antd/es/select/style/index.js":
      /*!****************************************************!*\
  !*** ./node_modules/antd/es/select/style/index.js ***!
  \****************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ../../style/index.less */ "./node_modules/antd/es/style/index.less"
        );
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
          _style_index_less__WEBPACK_IMPORTED_MODULE_0__
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! ./index.less */ "./node_modules/antd/es/select/style/index.less"
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
          _index_less__WEBPACK_IMPORTED_MODULE_1__
        );
        /* harmony import */ var _empty_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          /*! ../../empty/style */ "./node_modules/antd/es/empty/style/index.js"
        );

        // style dependencies

        /***/
      },

    /***/ "./node_modules/antd/es/spin/style/index.js":
      /*!**************************************************!*\
  !*** ./node_modules/antd/es/spin/style/index.js ***!
  \**************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ../../style/index.less */ "./node_modules/antd/es/style/index.less"
        );
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
          _style_index_less__WEBPACK_IMPORTED_MODULE_0__
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! ./index.less */ "./node_modules/antd/es/spin/style/index.less"
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
          _index_less__WEBPACK_IMPORTED_MODULE_1__
        );

        /***/
      },

    /***/ "./node_modules/antd/es/switch/style/index.js":
      /*!****************************************************!*\
  !*** ./node_modules/antd/es/switch/style/index.js ***!
  \****************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ../../style/index.less */ "./node_modules/antd/es/style/index.less"
        );
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
          _style_index_less__WEBPACK_IMPORTED_MODULE_0__
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! ./index.less */ "./node_modules/antd/es/switch/style/index.less"
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
          _index_less__WEBPACK_IMPORTED_MODULE_1__
        );

        /***/
      },

    /***/ "./node_modules/antd/es/time-picker/locale/zh_CN.js":
      /*!**********************************************************!*\
  !*** ./node_modules/antd/es/time-picker/locale/zh_CN.js ***!
  \**********************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var locale = {
          placeholder: "请选择时间",
          rangePlaceholder: ["开始时间", "结束时间"]
        };
        /* harmony default export */ __webpack_exports__["default"] = locale;

        /***/
      },

    /***/ "./node_modules/antd/es/tooltip/style/index.js":
      /*!*****************************************************!*\
  !*** ./node_modules/antd/es/tooltip/style/index.js ***!
  \*****************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ../../style/index.less */ "./node_modules/antd/es/style/index.less"
        );
        /* harmony import */ var _style_index_less__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(
          _style_index_less__WEBPACK_IMPORTED_MODULE_0__
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! ./index.less */ "./node_modules/antd/es/tooltip/style/index.less"
        );
        /* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(
          _index_less__WEBPACK_IMPORTED_MODULE_1__
        );

        /***/
      },

    /***/ "./node_modules/omit.js/es/index.js":
      /*!******************************************!*\
  !*** ./node_modules/omit.js/es/index.js ***!
  \******************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        function omit(obj, fields) {
          // eslint-disable-next-line prefer-object-spread
          var shallowCopy = Object.assign({}, obj);

          for (var i = 0; i < fields.length; i += 1) {
            var key = fields[i];
            delete shallowCopy[key];
          }

          return shallowCopy;
        }

        /* harmony default export */ __webpack_exports__["default"] = omit;

        /***/
      },

    /***/ "./node_modules/rc-picker/es/locale/zh_CN.js":
      /*!***************************************************!*\
  !*** ./node_modules/rc-picker/es/locale/zh_CN.js ***!
  \***************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var locale = {
          locale: "zh_CN",
          today: "今天",
          now: "此刻",
          backToToday: "返回今天",
          ok: "确定",
          timeSelect: "选择时间",
          dateSelect: "选择日期",
          weekSelect: "选择周",
          clear: "清除",
          month: "月",
          year: "年",
          previousMonth: "上个月 (翻页上键)",
          nextMonth: "下个月 (翻页下键)",
          monthSelect: "选择月份",
          yearSelect: "选择年份",
          decadeSelect: "选择年代",
          yearFormat: "YYYY年",
          dayFormat: "D日",
          dateFormat: "YYYY年M月D日",
          dateTimeFormat: "YYYY年M月D日 HH时mm分ss秒",
          previousYear: "上一年 (Control键加左方向键)",
          nextYear: "下一年 (Control键加右方向键)",
          previousDecade: "上一年代",
          nextDecade: "下一年代",
          previousCentury: "上一世纪",
          nextCentury: "下一世纪"
        };
        /* harmony default export */ __webpack_exports__["default"] = locale;

        /***/
      },

    /***/ "./node_modules/rc-resize-observer/es/index.js":
      /*!*****************************************************!*\
  !*** ./node_modules/rc-resize-observer/es/index.js ***!
  \*****************************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! @babel/runtime/helpers/esm/objectSpread2 */ "./node_modules/@babel/runtime/helpers/esm/objectSpread2.js"
        );
        /* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          /*! @babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js"
        );
        /* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          /*! @babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js"
        );
        /* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          /*! @babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js"
        );
        /* harmony import */ var _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          /*! @babel/runtime/helpers/esm/createSuper */ "./node_modules/@babel/runtime/helpers/esm/createSuper.js"
        );
        /* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          /*! react */ "./node_modules/react/index.js"
        );
        /* harmony import */ var rc_util_es_Dom_findDOMNode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          /*! rc-util/es/Dom/findDOMNode */ "./node_modules/rc-util/es/Dom/findDOMNode.js"
        );
        /* harmony import */ var rc_util_es_Children_toArray__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
          /*! rc-util/es/Children/toArray */ "./node_modules/rc-util/es/Children/toArray.js"
        );
        /* harmony import */ var rc_util_es_warning__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
          /*! rc-util/es/warning */ "./node_modules/rc-util/es/warning.js"
        );
        /* harmony import */ var rc_util_es_ref__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
          /*! rc-util/es/ref */ "./node_modules/rc-util/es/ref.js"
        );
        /* harmony import */ var resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
          /*! resize-observer-polyfill */ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js"
        );

        var INTERNAL_PREFIX_KEY = "rc-observer-key"; // Still need to be compatible with React 15, we use class component here

        var ReactResizeObserver = /*#__PURE__*/ (function(_React$Component) {
          (0,
          _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__.default)(
            ReactResizeObserver,
            _React$Component
          );

          var _super = (0,
          _babel_runtime_helpers_esm_createSuper__WEBPACK_IMPORTED_MODULE_4__.default)(
            ReactResizeObserver
          );

          function ReactResizeObserver() {
            var _this;

            (0,
            _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.default)(
              this,
              ReactResizeObserver
            );

            _this = _super.apply(this, arguments);
            _this.resizeObserver = null;
            _this.childNode = null;
            _this.currentElement = null;
            _this.state = {
              width: 0,
              height: 0,
              offsetHeight: 0,
              offsetWidth: 0
            };

            _this.onResize = function(entries) {
              var onResize = _this.props.onResize;
              var target = entries[0].target;

              var _target$getBoundingCl = target.getBoundingClientRect(),
                width = _target$getBoundingCl.width,
                height = _target$getBoundingCl.height;

              var offsetWidth = target.offsetWidth,
                offsetHeight = target.offsetHeight;
              /**
               * Resize observer trigger when content size changed.
               * In most case we just care about element size,
               * let's use `boundary` instead of `contentRect` here to avoid shaking.
               */

              var fixedWidth = Math.floor(width);
              var fixedHeight = Math.floor(height);

              if (
                _this.state.width !== fixedWidth ||
                _this.state.height !== fixedHeight ||
                _this.state.offsetWidth !== offsetWidth ||
                _this.state.offsetHeight !== offsetHeight
              ) {
                var size = {
                  width: fixedWidth,
                  height: fixedHeight,
                  offsetWidth: offsetWidth,
                  offsetHeight: offsetHeight
                };

                _this.setState(size);

                if (onResize) {
                  // defer the callback but not defer to next frame
                  Promise.resolve().then(function() {
                    onResize(
                      (0,
                      _babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__.default)(
                        (0,
                        _babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__.default)(
                          {},
                          size
                        ),
                        {},
                        {
                          offsetWidth: offsetWidth,
                          offsetHeight: offsetHeight
                        }
                      )
                    );
                  });
                }
              }
            };

            _this.setChildNode = function(node) {
              _this.childNode = node;
            };

            return _this;
          }

          (0,
          _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__.default)(
            ReactResizeObserver,
            [
              {
                key: "componentDidMount",
                value: function componentDidMount() {
                  this.onComponentUpdated();
                }
              },
              {
                key: "componentDidUpdate",
                value: function componentDidUpdate() {
                  this.onComponentUpdated();
                }
              },
              {
                key: "componentWillUnmount",
                value: function componentWillUnmount() {
                  this.destroyObserver();
                }
              },
              {
                key: "onComponentUpdated",
                value: function onComponentUpdated() {
                  var disabled = this.props.disabled; // Unregister if disabled

                  if (disabled) {
                    this.destroyObserver();
                    return;
                  } // Unregister if element changed

                  var element = (0,
                  rc_util_es_Dom_findDOMNode__WEBPACK_IMPORTED_MODULE_6__.default)(
                    this.childNode || this
                  );
                  var elementChanged = element !== this.currentElement;

                  if (elementChanged) {
                    this.destroyObserver();
                    this.currentElement = element;
                  }

                  if (!this.resizeObserver && element) {
                    this.resizeObserver = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_10__.default(
                      this.onResize
                    );
                    this.resizeObserver.observe(element);
                  }
                }
              },
              {
                key: "destroyObserver",
                value: function destroyObserver() {
                  if (this.resizeObserver) {
                    this.resizeObserver.disconnect();
                    this.resizeObserver = null;
                  }
                }
              },
              {
                key: "render",
                value: function render() {
                  var children = this.props.children;
                  var childNodes = (0,
                  rc_util_es_Children_toArray__WEBPACK_IMPORTED_MODULE_7__.default)(
                    children
                  );

                  if (childNodes.length > 1) {
                    (0,
                    rc_util_es_warning__WEBPACK_IMPORTED_MODULE_8__.default)(
                      false,
                      "Find more than one child node with `children` in ResizeObserver. Will only observe first one."
                    );
                  } else if (childNodes.length === 0) {
                    (0,
                    rc_util_es_warning__WEBPACK_IMPORTED_MODULE_8__.default)(
                      false,
                      "`children` of ResizeObserver is empty. Nothing is in observe."
                    );
                    return null;
                  }

                  var childNode = childNodes[0];

                  if (
                    react__WEBPACK_IMPORTED_MODULE_5__.isValidElement(
                      childNode
                    ) &&
                    (0, rc_util_es_ref__WEBPACK_IMPORTED_MODULE_9__.supportRef)(
                      childNode
                    )
                  ) {
                    var ref = childNode.ref;
                    childNodes[0] = react__WEBPACK_IMPORTED_MODULE_5__.cloneElement(
                      childNode,
                      {
                        ref: (0,
                        rc_util_es_ref__WEBPACK_IMPORTED_MODULE_9__.composeRef)(
                          ref,
                          this.setChildNode
                        )
                      }
                    );
                  }

                  return childNodes.length === 1
                    ? childNodes[0]
                    : childNodes.map(function(node, index) {
                        if (
                          !react__WEBPACK_IMPORTED_MODULE_5__.isValidElement(
                            node
                          ) ||
                          ("key" in node && node.key !== null)
                        ) {
                          return node;
                        }

                        return react__WEBPACK_IMPORTED_MODULE_5__.cloneElement(
                          node,
                          {
                            key: ""
                              .concat(INTERNAL_PREFIX_KEY, "-")
                              .concat(index)
                          }
                        );
                      });
                }
              }
            ]
          );

          return ReactResizeObserver;
        })(react__WEBPACK_IMPORTED_MODULE_5__.Component);

        ReactResizeObserver.displayName = "ResizeObserver";
        /* harmony default export */ __webpack_exports__[
          "default"
        ] = ReactResizeObserver;

        /***/
      },

    /***/ "./node_modules/swr/dist/index.esm.js":
      /*!********************************************!*\
  !*** ./node_modules/swr/dist/index.esm.js ***!
  \********************************************/
      /***/ function(
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ SWRConfig: function() {
            return /* binding */ SWRConfig;
          },
          /* harmony export */ default: function() {
            return /* binding */ useSWR;
          },
          /* harmony export */ mutate: function() {
            return /* binding */ mutate;
          },
          /* harmony export */ unstable_serialize: function() {
            return /* binding */ unstable_serialize;
          },
          /* harmony export */ useSWRConfig: function() {
            return /* binding */ useSWRConfig;
          }
          /* harmony export */
        });
        /* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! react */ "./node_modules/react/index.js"
        );

        /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

        function __awaiter(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function(resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done
                ? resolve(result.value)
                : adopt(result.value).then(fulfilled, rejected);
            }
            step(
              (generator = generator.apply(thisArg, _arguments || [])).next()
            );
          });
        }

        function __generator(thisArg, body) {
          var _ = {
              label: 0,
              sent: function() {
                if (t[0] & 1) throw t[1];
                return t[1];
              },
              trys: [],
              ops: []
            },
            f,
            y,
            t,
            g;
          return (
            (g = { next: verb(0), throw: verb(1), return: verb(2) }),
            typeof Symbol === "function" &&
              (g[Symbol.iterator] = function() {
                return this;
              }),
            g
          );
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (
                  ((f = 1),
                  y &&
                    (t =
                      op[0] & 2
                        ? y["return"]
                        : op[0]
                          ? y["throw"] || ((t = y["return"]) && t.call(y), 0)
                          : y.next) &&
                    !(t = t.call(y, op[1])).done)
                )
                  return t;
                if (((y = 0), t)) op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (
                      !((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&
                      (op[0] === 6 || op[0] === 2)
                    ) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5) throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        }

        var noop = function() {};
        // Using noop() as the undefined value as undefined can possibly be replaced
        // by something else.  Prettier ignore and extra parentheses are necessary here
        // to ensure that tsc doesn't remove the __NOINLINE__ comment.
        // prettier-ignore
        var UNDEFINED = ( /*#__NOINLINE__*/noop());
        var OBJECT = Object;
        var isUndefined = function(v) {
          return v === UNDEFINED;
        };
        var isFunction = function(v) {
          return typeof v == "function";
        };
        var mergeObjects = function(a, b) {
          return OBJECT.assign({}, a, b);
        };
        var STR_UNDEFINED = "undefined";
        var hasWindow = function() {
          return typeof window != STR_UNDEFINED;
        };
        var hasDocument = function() {
          return typeof document != STR_UNDEFINED;
        };

        // use WeakMap to store the object->key mapping
        // so the objects can be garbage collected.
        // WeakMap uses a hashtable under the hood, so the lookup
        // complexity is almost O(1).
        var table = new WeakMap();
        // counter of the key
        var counter = 0;
        // A stable hash implementation that supports:
        // - Fast and ensures unique hash properties
        // - Handles unserializable values
        // - Handles object key ordering
        // - Generates short results
        //
        // This is not a serialization function, and the result is not guaranteed to be
        // parsible.
        var stableHash = function(arg) {
          var type = typeof arg;
          var constructor = arg && arg.constructor;
          var isDate = constructor == Date;
          var result;
          var index;
          if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {
            // Object/function, not null/date/regexp. Use WeakMap to store the id first.
            // If it's already hashed, directly return the result.
            result = table.get(arg);
            if (result) return result;
            // Store the hash first for circular reference detection before entering the
            // recursive `stableHash` calls.
            // For other objects like set and map, we use this id directly as the hash.
            result = ++counter + "~";
            table.set(arg, result);
            if (constructor == Array) {
              // Array.
              result = "@";
              for (index = 0; index < arg.length; index++) {
                result += stableHash(arg[index]) + ",";
              }
              table.set(arg, result);
            }
            if (constructor == OBJECT) {
              // Object, sort keys.
              result = "#";
              var keys = OBJECT.keys(arg).sort();
              while (!isUndefined((index = keys.pop()))) {
                if (!isUndefined(arg[index])) {
                  result += index + ":" + stableHash(arg[index]) + ",";
                }
              }
              table.set(arg, result);
            }
          } else {
            result = isDate
              ? arg.toJSON()
              : type == "symbol"
                ? arg.toString()
                : type == "string"
                  ? JSON.stringify(arg)
                  : "" + arg;
          }
          return result;
        };

        /**
         * Due to bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,
         * it's not reliable to detect if the browser is currently online or offline
         * based on `navigator.onLine`.
         * As a work around, we always assume it's online on first load, and change
         * the status upon `online` or `offline` events.
         */
        var online = true;
        var isOnline = function() {
          return online;
        };
        var hasWin = hasWindow();
        var hasDoc = hasDocument();
        // For node and React Native, `add/removeEventListener` doesn't exist on window.
        var onWindowEvent =
          hasWin && window.addEventListener
            ? window.addEventListener.bind(window)
            : noop;
        var onDocumentEvent = hasDoc
          ? document.addEventListener.bind(document)
          : noop;
        var offWindowEvent =
          hasWin && window.removeEventListener
            ? window.removeEventListener.bind(window)
            : noop;
        var offDocumentEvent = hasDoc
          ? document.removeEventListener.bind(document)
          : noop;
        var isVisible = function() {
          var visibilityState = hasDoc && document.visibilityState;
          if (!isUndefined(visibilityState)) {
            return visibilityState !== "hidden";
          }
          return true;
        };
        var initFocus = function(cb) {
          // focus revalidate
          onDocumentEvent("visibilitychange", cb);
          onWindowEvent("focus", cb);
          return function() {
            offDocumentEvent("visibilitychange", cb);
            offWindowEvent("focus", cb);
          };
        };
        var initReconnect = function(cb) {
          // revalidate on reconnected
          var onOnline = function() {
            online = true;
            cb();
          };
          // nothing to revalidate, just update the status
          var onOffline = function() {
            online = false;
          };
          onWindowEvent("online", onOnline);
          onWindowEvent("offline", onOffline);
          return function() {
            offWindowEvent("online", onOnline);
            offWindowEvent("offline", onOffline);
          };
        };
        var preset = {
          isOnline: isOnline,
          isVisible: isVisible
        };
        var defaultConfigOptions = {
          initFocus: initFocus,
          initReconnect: initReconnect
        };

        var IS_SERVER = !hasWindow() || "Deno" in window;
        // Polyfill requestAnimationFrame
        var rAF = function(f) {
          return hasWindow()
            ? window["requestAnimationFrame"](f)
            : setTimeout(f, 1);
        };
        // React currently throws a warning when using useLayoutEffect on the server.
        // To get around it, we can conditionally useEffect on the server (no-op) and
        // useLayoutEffect in the browser.
        var useIsomorphicLayoutEffect = IS_SERVER
          ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect
          : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;
        // This assignment is to extend the Navigator type to use effectiveType.
        var navigatorConnection =
          typeof navigator !== "undefined" && navigator.connection;
        // Adjust the config based on slow connection status (<= 70Kbps).
        var slowConnection =
          !IS_SERVER &&
          navigatorConnection &&
          (["slow-2g", "2g"].includes(navigatorConnection.effectiveType) ||
            navigatorConnection.saveData);

        var serialize = function(key) {
          if (isFunction(key)) {
            try {
              key = key();
            } catch (err) {
              // dependencies not ready
              key = "";
            }
          }
          var args = [].concat(key);
          // If key is not falsy, or not an empty array, hash it.
          key =
            typeof key == "string"
              ? key
              : (Array.isArray(key)
                ? key.length
                : key)
                ? stableHash(key)
                : "";
          var errorKey = key ? "$err$" + key : "";
          var isValidatingKey = key ? "$req$" + key : "";
          return [key, args, errorKey, isValidatingKey];
        };

        // Global state used to deduplicate requests and store listeners
        var SWRGlobalState = new WeakMap();

        var FOCUS_EVENT = 0;
        var RECONNECT_EVENT = 1;
        var MUTATE_EVENT = 2;

        var broadcastState = function(
          cache,
          key,
          data,
          error,
          isValidating,
          revalidate
        ) {
          var _a = SWRGlobalState.get(cache),
            EVENT_REVALIDATORS = _a[0],
            STATE_UPDATERS = _a[1],
            CONCURRENT_PROMISES = _a[4],
            CONCURRENT_PROMISES_TS = _a[5];
          var revalidators = EVENT_REVALIDATORS[key];
          var updaters = STATE_UPDATERS[key] || [];
          // Always update states of all hooks.
          for (var i = 0; i < updaters.length; ++i) {
            updaters[i](data, error, isValidating);
          }
          // If we also need to revalidate, only do it for the first hook.
          if (revalidate) {
            // Invalidate the key by deleting the concurrent request markers so new
            // requests will not be deduped.
            delete CONCURRENT_PROMISES[key];
            delete CONCURRENT_PROMISES_TS[key];
            if (revalidators && revalidators[0]) {
              return revalidators[0](MUTATE_EVENT).then(function() {
                return cache.get(key);
              });
            }
          }
          return cache.get(key);
        };

        // Global timestamp.
        var __timestamp = 0;
        var getTimestamp = function() {
          return ++__timestamp;
        };

        var internalMutate = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return __awaiter(void 0, void 0, void 0, function() {
            var cache,
              _key,
              revalidate,
              _data,
              _a,
              key,
              keyErr,
              _b,
              MUTATION_TS,
              MUTATION_END_TS,
              data,
              error,
              beforeMutationTs,
              res;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  (cache = args[0]), (_key = args[1]);
                  revalidate = args[3] !== false;
                  _data = args[2];
                  (_a = serialize(_key)), (key = _a[0]), (keyErr = _a[2]);
                  if (!key) return [2 /*return*/];
                  (_b = SWRGlobalState.get(cache)),
                    (MUTATION_TS = _b[2]),
                    (MUTATION_END_TS = _b[3]);
                  // If there is no new data provided, revalidate the key with current state.
                  if (args.length < 3) {
                    // Revalidate and broadcast state.
                    return [
                      2 /*return*/,
                      broadcastState(
                        cache,
                        key,
                        cache.get(key),
                        cache.get(keyErr),
                        UNDEFINED,
                        revalidate
                      )
                    ];
                  }
                  beforeMutationTs = MUTATION_TS[key] = getTimestamp();
                  MUTATION_END_TS[key] = 0;
                  if (isFunction(_data)) {
                    // `_data` is a function, call it passing current cache value.
                    try {
                      _data = _data(cache.get(key));
                    } catch (err) {
                      // If it throws an error synchronously, we shouldn't update the cache.
                      error = err;
                    }
                  }
                  if (!(_data && isFunction(_data.then)))
                    return [3 /*break*/, 2];
                  return [
                    4 /*yield*/,
                    _data.catch(function(err) {
                      error = err;
                    })
                    // Check if other mutations have occurred since we've started this mutation.
                    // If there's a race we don't update cache or broadcast the change,
                    // just return the data.
                  ];
                case 1:
                  // This means that the mutation is async, we need to check timestamps to
                  // avoid race conditions.
                  data = _c.sent();
                  // Check if other mutations have occurred since we've started this mutation.
                  // If there's a race we don't update cache or broadcast the change,
                  // just return the data.
                  if (beforeMutationTs !== MUTATION_TS[key]) {
                    if (error) throw error;
                    return [2 /*return*/, data];
                  }
                  return [3 /*break*/, 3];
                case 2:
                  data = _data;
                  _c.label = 3;
                case 3:
                  // Only update cached data if there's no error. Data can be `undefined` here.
                  if (!error) {
                    cache.set(key, data);
                  }
                  // Always update or reset the error.
                  cache.set(keyErr, error);
                  // Reset the timestamp to mark the mutation has ended.
                  MUTATION_END_TS[key] = getTimestamp();
                  return [
                    4 /*yield*/,
                    broadcastState(
                      cache,
                      key,
                      data,
                      error,
                      UNDEFINED,
                      revalidate
                    )
                    // Throw error or return data
                  ];
                case 4:
                  res = _c.sent();
                  // Throw error or return data
                  if (error) throw error;
                  return [2 /*return*/, res];
              }
            });
          });
        };

        var revalidateAllKeys = function(revalidators, type) {
          for (var key in revalidators) {
            if (revalidators[key][0]) revalidators[key][0](type);
          }
        };
        var initCache = function(provider, options) {
          // The global state for a specific provider will be used to deduplicate
          // requests and store listeners. As well as a mutate function that bound to
          // the cache.
          // Provider's global state might be already initialized. Let's try to get the
          // global state associated with the provider first.
          if (!SWRGlobalState.has(provider)) {
            var opts = mergeObjects(defaultConfigOptions, options);
            // If there's no global state bound to the provider, create a new one with the
            // new mutate function.
            var EVENT_REVALIDATORS = {};
            var mutate = internalMutate.bind(UNDEFINED, provider);
            var unmount = noop;
            // Update the state if it's new, or the provider has been extended.
            SWRGlobalState.set(provider, [
              EVENT_REVALIDATORS,
              {},
              {},
              {},
              {},
              {},
              mutate
            ]);
            // This is a new provider, we need to initialize it and setup DOM events
            // listeners for `focus` and `reconnect` actions.
            if (!IS_SERVER) {
              var releaseFocus_1 = opts.initFocus(
                revalidateAllKeys.bind(
                  UNDEFINED,
                  EVENT_REVALIDATORS,
                  FOCUS_EVENT
                )
              );
              var releaseReconnect_1 = opts.initReconnect(
                revalidateAllKeys.bind(
                  UNDEFINED,
                  EVENT_REVALIDATORS,
                  RECONNECT_EVENT
                )
              );
              unmount = function() {
                releaseFocus_1 && releaseFocus_1();
                releaseReconnect_1 && releaseReconnect_1();
                // When un-mounting, we need to remove the cache provider from the state
                // storage too because it's a side-effect. Otherwise when re-mounting we
                // will not re-register those event listeners.
                SWRGlobalState.delete(provider);
              };
            }
            // We might want to inject an extra layer on top of `provider` in the future,
            // such as key serialization, auto GC, etc.
            // For now, it's just a `Map` interface without any modifications.
            return [provider, mutate, unmount];
          }
          return [provider, SWRGlobalState.get(provider)[6]];
        };

        // error retry
        var onErrorRetry = function(_, __, config, revalidate, opts) {
          if (!preset.isVisible()) {
            // If it's hidden, stop. It will auto revalidate when refocusing.
            return;
          }
          var maxRetryCount = config.errorRetryCount;
          var currentRetryCount = opts.retryCount;
          // Exponential backoff
          var timeout =
            ~~(
              (Math.random() + 0.5) *
              (1 << (currentRetryCount < 8 ? currentRetryCount : 8))
            ) * config.errorRetryInterval;
          if (
            !isUndefined(maxRetryCount) &&
            currentRetryCount > maxRetryCount
          ) {
            return;
          }
          setTimeout(revalidate, timeout, opts);
        };
        // Default cache provider
        var _a = initCache(new Map()),
          cache = _a[0],
          mutate = _a[1];
        // Default config
        var defaultConfig = mergeObjects(
          {
            // events
            onLoadingSlow: noop,
            onSuccess: noop,
            onError: noop,
            onErrorRetry: onErrorRetry,
            onDiscarded: noop,
            // switches
            revalidateOnFocus: true,
            revalidateOnReconnect: true,
            revalidateIfStale: true,
            shouldRetryOnError: true,
            // timeouts
            errorRetryInterval: slowConnection ? 10000 : 5000,
            focusThrottleInterval: 5 * 1000,
            dedupingInterval: 2 * 1000,
            loadingTimeout: slowConnection ? 5000 : 3000,
            // providers
            compare: function(currentData, newData) {
              return stableHash(currentData) == stableHash(newData);
            },
            isPaused: function() {
              return false;
            },
            cache: cache,
            mutate: mutate,
            fallback: {}
          },
          // use web preset by default
          preset
        );

        var mergeConfigs = function(a, b) {
          // Need to create a new object to avoid mutating the original here.
          var v = mergeObjects(a, b);
          // If two configs are provided, merge their `use` and `fallback` options.
          if (b) {
            var u1 = a.use,
              f1 = a.fallback;
            var u2 = b.use,
              f2 = b.fallback;
            if (u1 && u2) {
              v.use = u1.concat(u2);
            }
            if (f1 && f2) {
              v.fallback = mergeObjects(f1, f2);
            }
          }
          return v;
        };

        var SWRConfigContext = (0,
        react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});
        var SWRConfig$1 = function(props) {
          var value = props.value;
          // Extend parent context values and middleware.
          var extendedConfig = mergeConfigs(
            (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)(
              SWRConfigContext
            ),
            value
          );
          // Should not use the inherited provider.
          var provider = value && value.provider;
          // Use a lazy initialized state to create the cache on first access.
          var cacheContext = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(
            function() {
              return provider
                ? initCache(provider(extendedConfig.cache || cache), value)
                : UNDEFINED;
            }
          )[0];
          // Override the cache if a new provider is given.
          if (cacheContext) {
            extendedConfig.cache = cacheContext[0];
            extendedConfig.mutate = cacheContext[1];
          }
          // Unsubscribe events.
          useIsomorphicLayoutEffect(function() {
            return cacheContext ? cacheContext[2] : UNDEFINED;
          }, []);
          return (0, react__WEBPACK_IMPORTED_MODULE_0__.createElement)(
            SWRConfigContext.Provider,
            mergeObjects(props, {
              value: extendedConfig
            })
          );
        };

        /**
         * An implementation of state with dependency-tracking.
         */
        var useStateWithDeps = function(state, unmountedRef) {
          var rerender = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(
            {}
          )[1];
          var stateRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);
          // If a state property (data, error or isValidating) is accessed by the render
          // function, we mark the property as a dependency so if it is updated again
          // in the future, we trigger a rerender.
          // This is also known as dependency-tracking.
          var stateDependenciesRef = (0,
          react__WEBPACK_IMPORTED_MODULE_0__.useRef)({
            data: false,
            error: false,
            isValidating: false
          });
          /**
           * @param payload To change stateRef, pass the values explicitly to setState:
           * @example
           * ```js
           * setState({
           *   isValidating: false
           *   data: newData // set data to newData
           *   error: undefined // set error to undefined
           * })
           *
           * setState({
           *   isValidating: false
           *   data: undefined // set data to undefined
           *   error: err // set error to err
           * })
           * ```
           */
          var setState = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
            function(payload) {
              var shouldRerender = false;
              var currentState = stateRef.current;
              for (var _ in payload) {
                var k = _;
                // If the property has changed, update the state and mark rerender as
                // needed.
                if (currentState[k] !== payload[k]) {
                  currentState[k] = payload[k];
                  // If the property is accessed by the component, a rerender should be
                  // triggered.
                  if (stateDependenciesRef.current[k]) {
                    shouldRerender = true;
                  }
                }
              }
              if (shouldRerender && !unmountedRef.current) {
                rerender({});
              }
            },
            // config.suspense isn't allowed to change during the lifecycle
            // eslint-disable-next-line react-hooks/exhaustive-deps
            []
          );
          // Always update the state reference.
          useIsomorphicLayoutEffect(function() {
            stateRef.current = state;
          });
          return [stateRef, stateDependenciesRef.current, setState];
        };

        var normalize = function(args) {
          return isFunction(args[1])
            ? [args[0], args[1], args[2] || {}]
            : [args[0], null, (args[1] === null ? args[2] : args[1]) || {}];
        };

        var useSWRConfig = function() {
          return mergeObjects(
            defaultConfig,
            (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext)
          );
        };

        // It's tricky to pass generic types as parameters, so we just directly override
        // the types here.
        var withArgs = function(hook) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            // Get the default and inherited configuration.
            var fallbackConfig = useSWRConfig();
            // Normalize arguments.
            var _a = normalize(args),
              key = _a[0],
              fn = _a[1],
              _config = _a[2];
            // Merge configurations.
            var config = mergeConfigs(fallbackConfig, _config);
            // Apply middleware
            var next = hook;
            var use = config.use;
            if (use) {
              for (var i = use.length; i-- > 0; ) {
                next = use[i](next);
              }
            }
            return next(key, fn || config.fetcher, config);
          };
        };

        // Add a callback function to a list of keyed callback functions and return
        // the unsubscribe function.
        var subscribeCallback = function(key, callbacks, callback) {
          var keyedRevalidators = callbacks[key] || (callbacks[key] = []);
          keyedRevalidators.push(callback);
          return function() {
            var index = keyedRevalidators.indexOf(callback);
            if (index >= 0) {
              // O(1): faster than splice
              keyedRevalidators[index] =
                keyedRevalidators[keyedRevalidators.length - 1];
              keyedRevalidators.pop();
            }
          };
        };

        var WITH_DEDUPE = { dedupe: true };
        var useSWRHandler = function(_key, fn, config) {
          var cache = config.cache,
            compare = config.compare,
            fallbackData = config.fallbackData,
            suspense = config.suspense,
            revalidateOnMount = config.revalidateOnMount,
            refreshInterval = config.refreshInterval,
            refreshWhenHidden = config.refreshWhenHidden,
            refreshWhenOffline = config.refreshWhenOffline;
          var _a = SWRGlobalState.get(cache),
            EVENT_REVALIDATORS = _a[0],
            STATE_UPDATERS = _a[1],
            MUTATION_TS = _a[2],
            MUTATION_END_TS = _a[3],
            CONCURRENT_PROMISES = _a[4],
            CONCURRENT_PROMISES_TS = _a[5];
          // `key` is the identifier of the SWR `data` state, `keyErr` and
          // `keyValidating` are identifiers of `error` and `isValidating`,
          // all of them are derived from `_key`.
          // `fnArgs` is an array of arguments parsed from the key, which will be passed
          // to the fetcher.
          var _b = serialize(_key),
            key = _b[0],
            fnArgs = _b[1],
            keyErr = _b[2],
            keyValidating = _b[3];
          // If it's the initial render of this hook.
          var initialMountedRef = (0,
          react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
          // If the hook is unmounted already. This will be used to prevent some effects
          // to be called after unmounting.
          var unmountedRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(
            false
          );
          // Refs to keep the key and config.
          var keyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);
          var configRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(
            config
          );
          var getConfig = function() {
            return configRef.current;
          };
          // Get the current state that SWR should return.
          var cached = cache.get(key);
          var fallback = isUndefined(fallbackData)
            ? config.fallback[key]
            : fallbackData;
          var data = isUndefined(cached) ? fallback : cached;
          var error = cache.get(keyErr);
          // - Suspense mode and there's stale data for the initial render.
          // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.
          // - `revalidateIfStale` is enabled but `data` is not defined.
          var shouldRevalidateOnMount = function() {
            // If `revalidateOnMount` is set, we take the value directly.
            if (!isUndefined(revalidateOnMount)) return revalidateOnMount;
            // If it's paused, we skip revalidation.
            if (getConfig().isPaused()) return false;
            return suspense
              ? // Under suspense mode, it will always fetch on render if there is no
                // stale data so no need to revalidate immediately on mount again.
                !isUndefined(data)
              : // If there is no stale data, we need to revalidate on mount;
                // If `revalidateIfStale` is set to true, we will always revalidate.
                isUndefined(data) || config.revalidateIfStale;
          };
          // Resolve the current validating state.
          var resolveValidating = function() {
            if (!key || !fn) return false;
            if (cache.get(keyValidating)) return true;
            // If it's not mounted yet and it should revalidate on mount, revalidate.
            return !initialMountedRef.current && shouldRevalidateOnMount();
          };
          var isValidating = resolveValidating();
          var _c = useStateWithDeps(
              {
                data: data,
                error: error,
                isValidating: isValidating
              },
              unmountedRef
            ),
            stateRef = _c[0],
            stateDependencies = _c[1],
            setState = _c[2];
          // The revalidation function is a carefully crafted wrapper of the original
          // `fetcher`, to correctly handle the many edge cases.
          var revalidate = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
            function(revalidateOpts) {
              return __awaiter(void 0, void 0, void 0, function() {
                var newData,
                  startAt,
                  loading,
                  opts,
                  shouldStartNewRequest,
                  isCurrentKeyMounted,
                  cleanupState,
                  newState,
                  finishRequestAndUpdateState,
                  err_1;
                return __generator(this, function(_a) {
                  switch (_a.label) {
                    case 0:
                      if (
                        !key ||
                        !fn ||
                        unmountedRef.current ||
                        getConfig().isPaused()
                      ) {
                        return [2 /*return*/, false];
                      }
                      loading = true;
                      opts = revalidateOpts || {};
                      shouldStartNewRequest =
                        isUndefined(CONCURRENT_PROMISES[key]) || !opts.dedupe;
                      isCurrentKeyMounted = function() {
                        return (
                          !unmountedRef.current &&
                          key === keyRef.current &&
                          initialMountedRef.current
                        );
                      };
                      cleanupState = function() {
                        // CONCURRENT_PROMISES_TS[key] might be overridden, check if it's still
                        // the same request before deleting.
                        if (CONCURRENT_PROMISES_TS[key] === startAt) {
                          delete CONCURRENT_PROMISES[key];
                          delete CONCURRENT_PROMISES_TS[key];
                        }
                      };
                      newState = { isValidating: false };
                      finishRequestAndUpdateState = function() {
                        cache.set(keyValidating, false);
                        // We can only set state if it's safe (still mounted with the same key).
                        if (isCurrentKeyMounted()) {
                          setState(newState);
                        }
                      };
                      // Start fetching. Change the `isValidating` state, update the cache.
                      cache.set(keyValidating, true);
                      setState({ isValidating: true });
                      _a.label = 1;
                    case 1:
                      _a.trys.push([1, 3, , 4]);
                      if (shouldStartNewRequest) {
                        // Tell all other hooks to change the `isValidating` state.
                        broadcastState(
                          cache,
                          key,
                          stateRef.current.data,
                          stateRef.current.error,
                          true
                        );
                        // If no cache being rendered currently (it shows a blank page),
                        // we trigger the loading slow event.
                        if (config.loadingTimeout && !cache.get(key)) {
                          setTimeout(function() {
                            if (loading && isCurrentKeyMounted()) {
                              getConfig().onLoadingSlow(key, config);
                            }
                          }, config.loadingTimeout);
                        }
                        // Start the request and keep the timestamp.
                        CONCURRENT_PROMISES_TS[key] = getTimestamp();
                        CONCURRENT_PROMISES[key] = fn.apply(void 0, fnArgs);
                      }
                      // Wait until the ongoing request is done. Deduplication is also
                      // considered here.
                      startAt = CONCURRENT_PROMISES_TS[key];
                      return [4 /*yield*/, CONCURRENT_PROMISES[key]];
                    case 2:
                      newData = _a.sent();
                      if (shouldStartNewRequest) {
                        // If the request isn't interrupted, clean it up after the
                        // deduplication interval.
                        setTimeout(cleanupState, config.dedupingInterval);
                      }
                      // If there're other ongoing request(s), started after the current one,
                      // we need to ignore the current one to avoid possible race conditions:
                      //   req1------------------>res1        (current one)
                      //        req2---------------->res2
                      // the request that fired later will always be kept.
                      // CONCURRENT_PROMISES_TS[key] maybe be `undefined` or a number
                      if (CONCURRENT_PROMISES_TS[key] !== startAt) {
                        if (shouldStartNewRequest) {
                          if (isCurrentKeyMounted()) {
                            getConfig().onDiscarded(key);
                          }
                        }
                        return [2 /*return*/, false];
                      }
                      // Clear error.
                      cache.set(keyErr, UNDEFINED);
                      newState.error = UNDEFINED;
                      // If there're other mutations(s), overlapped with the current revalidation:
                      // case 1:
                      //   req------------------>res
                      //       mutate------>end
                      // case 2:
                      //         req------------>res
                      //   mutate------>end
                      // case 3:
                      //   req------------------>res
                      //       mutate-------...---------->
                      // we have to ignore the revalidation result (res) because it's no longer fresh.
                      // meanwhile, a new revalidation should be triggered when the mutation ends.
                      if (
                        !isUndefined(MUTATION_TS[key]) &&
                        // case 1
                        (startAt <= MUTATION_TS[key] ||
                          // case 2
                          startAt <= MUTATION_END_TS[key] ||
                          // case 3
                          MUTATION_END_TS[key] === 0)
                      ) {
                        finishRequestAndUpdateState();
                        if (shouldStartNewRequest) {
                          if (isCurrentKeyMounted()) {
                            getConfig().onDiscarded(key);
                          }
                        }
                        return [2 /*return*/, false];
                      }
                      // Deep compare with latest state to avoid extra re-renders.
                      // For local state, compare and assign.
                      if (!compare(stateRef.current.data, newData)) {
                        newState.data = newData;
                      }
                      // For global state, it's possible that the key has changed.
                      // https://github.com/vercel/swr/pull/1058
                      if (!compare(cache.get(key), newData)) {
                        cache.set(key, newData);
                      }
                      // Trigger the successful callback if it's the original request.
                      if (shouldStartNewRequest) {
                        if (isCurrentKeyMounted()) {
                          getConfig().onSuccess(newData, key, config);
                        }
                      }
                      return [3 /*break*/, 4];
                    case 3:
                      err_1 = _a.sent();
                      cleanupState();
                      // Not paused, we continue handling the error. Otherwise discard it.
                      if (!getConfig().isPaused()) {
                        // Get a new error, don't use deep comparison for errors.
                        cache.set(keyErr, err_1);
                        newState.error = err_1;
                        // Error event and retry logic. Only for the actual request, not
                        // deduped ones.
                        if (shouldStartNewRequest && isCurrentKeyMounted()) {
                          getConfig().onError(err_1, key, config);
                          if (config.shouldRetryOnError) {
                            // When retrying, dedupe is always enabled
                            getConfig().onErrorRetry(
                              err_1,
                              key,
                              config,
                              revalidate,
                              {
                                retryCount: (opts.retryCount || 0) + 1,
                                dedupe: true
                              }
                            );
                          }
                        }
                      }
                      return [3 /*break*/, 4];
                    case 4:
                      // Mark loading as stopped.
                      loading = false;
                      // Update the current hook's state.
                      finishRequestAndUpdateState();
                      // Here is the source of the request, need to tell all other hooks to
                      // update their states.
                      if (isCurrentKeyMounted() && shouldStartNewRequest) {
                        broadcastState(
                          cache,
                          key,
                          newState.data,
                          newState.error,
                          false
                        );
                      }
                      return [2 /*return*/, true];
                  }
                });
              });
            },
            // `setState` is immutable, and `eventsCallback`, `fnArgs`, `keyErr`,
            // and `keyValidating` are depending on `key`, so we can exclude them from
            // the deps array.
            //
            // FIXME:
            // `fn` and `config` might be changed during the lifecycle,
            // but they might be changed every render like this.
            // `useSWR('key', () => fetch('/api/'), { suspense: true })`
            // So we omit the values from the deps array
            // even though it might cause unexpected behaviors.
            // eslint-disable-next-line react-hooks/exhaustive-deps
            [key]
          );
          // Similar to the global mutate, but bound to the current cache and key.
          // `cache` isn't allowed to change during the lifecycle.
          // eslint-disable-next-line react-hooks/exhaustive-deps
          var boundMutate = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
            // By using `bind` we don't need to modify the size of the rest arguments.
            internalMutate.bind(UNDEFINED, cache, function() {
              return keyRef.current;
            }),
            // eslint-disable-next-line react-hooks/exhaustive-deps
            []
          );
          // Always update config.
          useIsomorphicLayoutEffect(function() {
            configRef.current = config;
          });
          // After mounted or key changed.
          useIsomorphicLayoutEffect(
            function() {
              if (!key) return;
              // Not the initial render.
              var keyChanged = initialMountedRef.current;
              var softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);
              var isActive = function() {
                return getConfig().isVisible() && getConfig().isOnline();
              };
              // Expose state updater to global event listeners. So we can update hook's
              // internal state from the outside.
              var onStateUpdate = function(
                updatedData,
                updatedError,
                updatedIsValidating
              ) {
                setState(
                  mergeObjects(
                    {
                      error: updatedError,
                      isValidating: updatedIsValidating
                    },
                    // Since `setState` only shallowly compares states, we do a deep
                    // comparison here.
                    compare(stateRef.current.data, updatedData)
                      ? UNDEFINED
                      : {
                          data: updatedData
                        }
                  )
                );
              };
              // Expose revalidators to global event listeners. So we can trigger
              // revalidation from the outside.
              var nextFocusRevalidatedAt = 0;
              var onRevalidate = function(type) {
                if (type == FOCUS_EVENT) {
                  var now = Date.now();
                  if (
                    getConfig().revalidateOnFocus &&
                    now > nextFocusRevalidatedAt &&
                    isActive()
                  ) {
                    nextFocusRevalidatedAt =
                      now + getConfig().focusThrottleInterval;
                    softRevalidate();
                  }
                } else if (type == RECONNECT_EVENT) {
                  if (getConfig().revalidateOnReconnect && isActive()) {
                    softRevalidate();
                  }
                } else if (type == MUTATE_EVENT) {
                  return revalidate();
                }
                return;
              };
              var unsubUpdate = subscribeCallback(
                key,
                STATE_UPDATERS,
                onStateUpdate
              );
              var unsubEvents = subscribeCallback(
                key,
                EVENT_REVALIDATORS,
                onRevalidate
              );
              // Mark the component as mounted and update corresponding refs.
              unmountedRef.current = false;
              keyRef.current = key;
              initialMountedRef.current = true;
              // When `key` updates, reset the state to the initial value
              // and trigger a rerender if necessary.
              if (keyChanged) {
                setState({
                  data: data,
                  error: error,
                  isValidating: isValidating
                });
              }
              // Trigger a revalidation.
              if (shouldRevalidateOnMount()) {
                if (isUndefined(data) || IS_SERVER) {
                  // Revalidate immediately.
                  softRevalidate();
                } else {
                  // Delay the revalidate if we have data to return so we won't block
                  // rendering.
                  rAF(softRevalidate);
                }
              }
              return function() {
                // Mark it as unmounted.
                unmountedRef.current = true;
                unsubUpdate();
                unsubEvents();
              };
            },
            [key, revalidate]
          );
          // Polling
          useIsomorphicLayoutEffect(
            function() {
              var timer;
              function next() {
                // We only start next interval if `refreshInterval` is not 0, and:
                // - `force` is true, which is the start of polling
                // - or `timer` is not 0, which means the effect wasn't canceled
                if (refreshInterval && timer !== -1) {
                  timer = setTimeout(execute, refreshInterval);
                }
              }
              function execute() {
                // Check if it's OK to execute:
                // Only revalidate when the page is visible, online and not errored.
                if (
                  !stateRef.current.error &&
                  (refreshWhenHidden || getConfig().isVisible()) &&
                  (refreshWhenOffline || getConfig().isOnline())
                ) {
                  revalidate(WITH_DEDUPE).then(next);
                } else {
                  // Schedule next interval to check again.
                  next();
                }
              }
              next();
              return function() {
                if (timer) {
                  clearTimeout(timer);
                  timer = -1;
                }
              };
            },
            [refreshInterval, refreshWhenHidden, refreshWhenOffline, revalidate]
          );
          // Display debug info in React DevTools.
          (0, react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(data);
          // In Suspense mode, we can't return the empty `data` state.
          // If there is `error`, the `error` needs to be thrown to the error boundary.
          // If there is no `error`, the `revalidation` promise needs to be thrown to
          // the suspense boundary.
          if (suspense && isUndefined(data)) {
            throw isUndefined(error) ? revalidate(WITH_DEDUPE) : error;
          }
          return {
            mutate: boundMutate,
            get data() {
              stateDependencies.data = true;
              return data;
            },
            get error() {
              stateDependencies.error = true;
              return error;
            },
            get isValidating() {
              stateDependencies.isValidating = true;
              return isValidating;
            }
          };
        };
        var SWRConfig = OBJECT.defineProperty(SWRConfig$1, "default", {
          value: defaultConfig
        });
        var unstable_serialize = function(key) {
          return serialize(key)[0];
        };
        var useSWR = withArgs(useSWRHandler);

        // useSWR

        /***/
      }
  }
]);
